import functools
from typing import Any
import datetime
import os
import re

import pytest
import cocotb_tools.runner


DIR_TESTS = os.path.join(os.path.abspath("."), "tests") # TODO: ability to change path

STUB_CODE = """
# This file was automatically generated by testtools.
# Required because of importlib's inability to import .pyi files
def __getattr__(name):
    return None
"""

def read_dependencies_file(file_path: str = "build/file_compile_order.txt") -> dict[str, list[str]]:
    """
    Read the dependecies file generated by the dependency.tcl script.
    Returns a dictionary mapping module names to a list of source files.
    """
    # TODO: fail more gracefully
    with open(file_path) as f: # TODO: ability to change path
        dependencies = f.read().split("\n")

    def parse_line(line: str) -> tuple[str, list[str]]:
        parts = line.split(" ", 1)
        if len(parts) != 2:
            raise RuntimeError(f"Could not parse dependency line: '{line}'")
        module, files = parts
        return module, files.split(":")

    return dict(parse_line(line) for line in dependencies if line)

def get_dependencies(verilog_module: str):
    dependencies = read_dependencies_file()

    if verilog_module in dependencies:
        return dependencies[verilog_module]
    
    raise RuntimeError(f"Could not find file compile order for module '{verilog_module}'")

def parameters_to_safe_filename(parameters: dict) -> str:
    # Sort keys for deterministic order
    unsafe = "_".join([f"{key}-{parameters[key]}" for key in sorted(parameters)])
    safe = re.sub(r'[^a-zA-Z0-9_.-]', '_', unsafe)
    return safe

def create_test(toplevel: str, filename: str, module_name: str, testcase: str | None = None, parameters: dict[str, Any] | None = None):
    if parameters is None:
        parameters = {}

    def decorator(func):
        files = get_dependencies(toplevel)

        @functools.wraps(func)
        @pytest.mark.module(filename, module_name, testcase)
        def wrapper(*args, **kwargs):
            del args, kwargs  # ignore args

            # Setup stubs
            os.environ["COPRA_STUB_DIR"] = os.path.join(DIR_TESTS, "stubs")
            os.environ["COPRA_STUB_FILENAME"] = "".join((toplevel.lower(), ".pyi"))
            filename = os.path.join(DIR_TESTS, "stubs", toplevel.lower() + ".py")
            with open(filename, "w") as f:
                f.write(STUB_CODE)

            build_dir = f"build/test/simbuild_{toplevel}"
            build_dir = os.path.abspath(build_dir)
            if len(parameters) > 0:
                build_dir += "_" + parameters_to_safe_filename(parameters)
            runner = cocotb_tools.runner.Verilator()
            runner.build(
                sources=files,
                hdl_toplevel=toplevel,
                includes=["."],
                build_args=["--structs-packed", "-DSIMULATION", "--trace", "--trace-structs"],
                waves=True,
                build_dir=build_dir,
                parameters=parameters,
            )

            try:
                runner.test(
                    hdl_toplevel=toplevel,
                    test_module=",".join(("copra.integration.autostub", module_name)),
                    test_filter=f"({testcase}|copra.integration.autostub)",
                    build_dir=build_dir,
                    test_dir=DIR_TESTS,
                    waves=True,
                    results_xml=f"{build_dir}/results.xml",
                )
            except:
                raise
            finally:
                # Move the "dump.vcd"-file generated
                os.makedirs("waveform/history/", exist_ok=True)

                timestamp = datetime.datetime.now(tz=datetime.timezone.utc).strftime("%Y%m%d%H%M%S")
                vcd_name = os.path.abspath(f"waveform/history/{testcase}_{timestamp}.vcd")
                os.rename(f"{DIR_TESTS}/dump.vcd", vcd_name)

                vcd_symlink = f"waveform/{testcase}.vcd"
                if os.path.exists(vcd_symlink):
                    os.remove(vcd_symlink)
                os.symlink(vcd_name, vcd_symlink)

        return wrapper

    return decorator
